
# SPDX-License-Identifier: Apache-2.0
# Copyright 2019 Eotvos Lorand University, Budapest, Hungary

# Autogenerated file (from compiler/backend/stateful_memory.h.py), do not modify directly.
# Generator: PPK

global file_indentation_level
file_indentation_level = 0

# The last element is the innermost (current) style.
file_sugar_style = ['line_comment']


def add_code(line, lineno = None, file = "compiler/backend/stateful_memory.h.py"):
    global file_indentation_level
    global file_sugar_style
    global generated_code

    line_ends = {
        "line_comment": "\n",
        "inline_comment": "",
    }

    stripped_line = line.strip()
    no_sugar_on_line = stripped_line.startswith('//') or stripped_line.startswith('# ') or stripped_line == ""

    indent = '    ' * file_indentation_level
    return indent + line + sugar(no_sugar_on_line, file, lineno) + line_ends[file_sugar_style[-1]]


class SugarStyle():
    def __init__(self, sugar):
        global file_sugar_style
        file_sugar_style.append(sugar)

    def __enter__(self):
        global file_sugar_style
        return file_sugar_style[-1]

    def __exit__(self, type, value, traceback):
        global file_sugar_style
        file_sugar_style.pop()


def sugar(no_sugar_on_line, file, lineno):
    if no_sugar_on_line or file is None or lineno is None:
        return ""

    import re
    global file_sugar_style

    if file_sugar_style[-1] == 'line_comment':
        if no_sugar_on_line:
            return ""
        return " // {}:{}".format(file, lineno)
    if file_sugar_style[-1] == 'inline_comment':
        if file == "../compiler/backend/stateful_memory.h.py":
            return " /* {} */ {}".format(lineno)
        return " /* {}:{} */".format(file, lineno)
    return line


generated_code += "// Autogenerated file (from compiler/backend/stateful_memory.h.py via ../compiler/backend/stateful_memory.h.py), do not modify directly.\n"
generated_code += "// Generator: PPK\n"
generated_code += "\n"

# Copyright 2018 Eotvos Lorand University, Budapest, Hungary ## compiler/backend/stateful_memory.h.py:2
#  ## compiler/backend/stateful_memory.h.py:3
# Licensed under the Apache License, Version 2.0 (the "License"); ## compiler/backend/stateful_memory.h.py:4
# you may not use this file except in compliance with the License. ## compiler/backend/stateful_memory.h.py:5
# You may obtain a copy of the License at ## compiler/backend/stateful_memory.h.py:6
#  ## compiler/backend/stateful_memory.h.py:7
#     http://www.apache.org/licenses/LICENSE-2.0 ## compiler/backend/stateful_memory.h.py:8
#  ## compiler/backend/stateful_memory.h.py:9
# Unless required by applicable law or agreed to in writing, software ## compiler/backend/stateful_memory.h.py:10
# distributed under the License is distributed on an "AS IS" BASIS, ## compiler/backend/stateful_memory.h.py:11
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ## compiler/backend/stateful_memory.h.py:12
# See the License for the specific language governing permissions and ## compiler/backend/stateful_memory.h.py:13
# limitations under the License. ## compiler/backend/stateful_memory.h.py:14

generated_code += add_code("")
from utils.misc import addError ## compiler/backend/stateful_memory.h.py:16
from utils.codegen import format_expr, format_type, format_statement, statement_buffer_value, format_declaration ## compiler/backend/stateful_memory.h.py:17

generated_code += add_code("")
def unique_stable(items): ## compiler/backend/stateful_memory.h.py:20
    """Returns only the first occurrence of the items in a list. ## compiler/backend/stateful_memory.h.py:21
    Equivalent to unique_everseen from Python 3.""" ## compiler/backend/stateful_memory.h.py:22
    from collections import OrderedDict ## compiler/backend/stateful_memory.h.py:23
    return list(OrderedDict.fromkeys(items)) ## compiler/backend/stateful_memory.h.py:24
def gen_make_smem_code(smem, table = None): ## compiler/backend/stateful_memory.h.py:27
    generated_code = ""
    size = smem.bit_width ## compiler/backend/stateful_memory.h.py:28
    type = smem.type._baseType.path.name ## compiler/backend/stateful_memory.h.py:29
    # TODO have just one lock even if there are two components ## compiler/backend/stateful_memory.h.py:31
    for c in smem.components: ## compiler/backend/stateful_memory.h.py:32
        cname =  c['name'] ## compiler/backend/stateful_memory.h.py:33
        ctype =  c['type'] ## compiler/backend/stateful_memory.h.py:34
        if smem.smem_type == "register": ## compiler/backend/stateful_memory.h.py:35
            signed = "int" if smem.is_signed else "uint" ## compiler/backend/stateful_memory.h.py:36
            bit_width = smem.bit_width ## compiler/backend/stateful_memory.h.py:37
            size = 8 if bit_width <= 8 else 16 if bit_width <= 16 else 32 if bit_width <= 32 else 64 ## compiler/backend/stateful_memory.h.py:38
            c['vartype'] = "register_{}{}_t".format(signed, size) ## compiler/backend/stateful_memory.h.py:39
            generated_code += add_code('     lock_t lock_{}[{}];'.format(cname, smem.amount), 39)
            generated_code += add_code('     {} {}[{}];'.format(c['vartype'], cname, smem.amount), 40)
            generated_code += add_code('     int {}_amount;'.format(cname), 41)
        elif table: ## compiler/backend/stateful_memory.h.py:43
            sname = "{}_{}".format(cname, table.name) ## compiler/backend/stateful_memory.h.py:44
            generated_code += add_code('     lock_t lock_{};'.format(sname), 45)
            generated_code += add_code('     {}_t {};'.format(smem.type._baseType.path.name, sname), 46)
            generated_code += add_code("", 47)
        else: ## compiler/backend/stateful_memory.h.py:49
            generated_code += add_code('     lock_t lock_{}[{}];'.format(cname, smem.amount), 49)
            generated_code += add_code('     {}_t {}[{}];'.format(smem.type._baseType.path.name, cname, smem.amount), 50)
            generated_code += add_code('     int {}_amount;'.format(cname), 51)
        generated_code += add_code("", 53)
    return generated_code
generated_code += add_code(" #ifndef __STATEFUL_MEMORY_H_", 56)
generated_code += add_code(" #define __STATEFUL_MEMORY_H_", 57)

generated_code += add_code("")
generated_code += add_code(" #include \"common.h\"", 59)
generated_code += add_code(" #include \"aliases.h\"", 60)
generated_code += add_code(" #include \"dpdk_smem.h\"", 61)

generated_code += add_code("")
generated_code += add_code(" typedef struct global_state_s {", 63)
for table, smem in hlir16.all_meters + hlir16.all_counters: ## compiler/backend/stateful_memory.h.py:65
    if smem.smem_type not in ["direct_counter", "direct_meter"]: ## compiler/backend/stateful_memory.h.py:66
        continue ## compiler/backend/stateful_memory.h.py:67
    generated_code += str( gen_make_smem_code(smem, table)) ## compiler/backend/stateful_memory.h.py:67
for smem in unique_stable([smem for table, smem in hlir16.all_meters + hlir16.all_counters if smem.smem_type not in ["direct_counter", "direct_meter"]]): ## compiler/backend/stateful_memory.h.py:69
    generated_code += str( gen_make_smem_code(smem)) ## compiler/backend/stateful_memory.h.py:69
for smem in hlir16.registers: ## compiler/backend/stateful_memory.h.py:71
    generated_code += str( gen_make_smem_code(smem)) ## compiler/backend/stateful_memory.h.py:71
all_locals = unique_stable([(param.name, format_type(param.type)) for table in hlir16.tables for local in table.control.controlLocals["P4Action"] for param in local.parameters.parameters]) ## compiler/backend/stateful_memory.h.py:76
all_locals_dict = dict(all_locals) ## compiler/backend/stateful_memory.h.py:77
if len(all_locals) != len(all_locals_dict): ## compiler/backend/stateful_memory.h.py:78
    names = [name for name, _type in all_locals] ## compiler/backend/stateful_memory.h.py:79
    dups = unique_stable([name for name in names if names.count(name) > 1]) ## compiler/backend/stateful_memory.h.py:80
    addError("Collecting counters, meters, registers and controls' local variables", "The following names are used with different types, which is currently unsupported: {}".format(", ".join(dups))) ## compiler/backend/stateful_memory.h.py:81
for locname, loctype in all_locals: ## compiler/backend/stateful_memory.h.py:83
    generated_code += add_code('     {} {};'.format(loctype, locname), 83)
# Note: currently all control locals are put together into the global state ## compiler/backend/stateful_memory.h.py:87
for ctl in hlir16.controls: ## compiler/backend/stateful_memory.h.py:88
    for local_var_decl in ctl.controlLocals['Declaration_Variable'] + ctl.controlLocals['Declaration_Instance']: ## compiler/backend/stateful_memory.h.py:89
        if hasattr(local_var_decl.type, 'type_ref'): ## compiler/backend/stateful_memory.h.py:90
            if local_var_decl.type.type_ref.name in ['counter', 'direct_counter', 'meter']: ## compiler/backend/stateful_memory.h.py:91
                continue ## compiler/backend/stateful_memory.h.py:92
        else: ## compiler/backend/stateful_memory.h.py:93
            if local_var_decl.type('baseType.type_ref.name', lambda n: n in ['direct_meter', 'register']): ## compiler/backend/stateful_memory.h.py:94
                continue ## compiler/backend/stateful_memory.h.py:95
        postfix = "_t" if local_var_decl.type.node_type == 'Type_Name' else "" ## compiler/backend/stateful_memory.h.py:96
        generated_code += add_code('     {}{} {};'.format(format_type(local_var_decl.type, resolve_names = False), postfix, local_var_decl.name), 96)
generated_code += add_code(" } global_state_t;", 101)

generated_code += add_code("")
generated_code += add_code(" extern global_state_t global_smem;", 103)

generated_code += add_code("")
generated_code += add_code(" static lock_t ingress_lock;", 106)
generated_code += add_code(" static lock_t egress_lock;", 107)

generated_code += add_code("")
generated_code += add_code(" #endif", 110)
