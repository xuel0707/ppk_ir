
# SPDX-License-Identifier: Apache-2.0
# Copyright 2019 Eotvos Lorand University, Budapest, Hungary

# Autogenerated file (from compiler/backend/common.h.py), do not modify directly.
# Generator: PPK

global file_indentation_level
file_indentation_level = 0

# The last element is the innermost (current) style.
file_sugar_style = ['line_comment']


def add_code(line, lineno = None, file = "compiler/backend/common.h.py"):
    global file_indentation_level
    global file_sugar_style
    global generated_code

    line_ends = {
        "line_comment": "\n",
        "inline_comment": "",
    }

    stripped_line = line.strip()
    no_sugar_on_line = stripped_line.startswith('//') or stripped_line.startswith('# ') or stripped_line == ""

    indent = '    ' * file_indentation_level
    return indent + line + sugar(no_sugar_on_line, file, lineno) + line_ends[file_sugar_style[-1]]


class SugarStyle():
    def __init__(self, sugar):
        global file_sugar_style
        file_sugar_style.append(sugar)

    def __enter__(self):
        global file_sugar_style
        return file_sugar_style[-1]

    def __exit__(self, type, value, traceback):
        global file_sugar_style
        file_sugar_style.pop()


def sugar(no_sugar_on_line, file, lineno):
    if no_sugar_on_line or file is None or lineno is None:
        return ""

    import re
    global file_sugar_style

    if file_sugar_style[-1] == 'line_comment':
        if no_sugar_on_line:
            return ""
        return " // {}:{}".format(file, lineno)
    if file_sugar_style[-1] == 'inline_comment':
        if file == "../compiler/backend/common.h.py":
            return " /* {} */ {}".format(lineno)
        return " /* {}:{} */".format(file, lineno)
    return line


generated_code += "// Autogenerated file (from compiler/backend/common.h.py via ../compiler/backend/common.h.py), do not modify directly.\n"
generated_code += "// Generator: PPK\n"
generated_code += "\n"

generated_code += add_code(" // SPDX-License-Identifier: Apache-2.0", 1)
generated_code += add_code(" // Copyright 2019 Eotvos Lorand University, Budapest, Hungary", 2)

generated_code += add_code("")
from hlir16.utils_hlir16 import * ## compiler/backend/common.h.py:5
from utils.codegen import format_type ## compiler/backend/common.h.py:6

generated_code += add_code("")
generated_code += add_code(" #ifndef __COMMON_H__", 7)
generated_code += add_code(" #define __COMMON_H__", 8)

generated_code += add_code("")
generated_code += add_code(" #include <stdint.h>", 10)
generated_code += add_code(" #include \"parser.h\"", 11)

generated_code += add_code("")
for typedef in hlir16.objects['Type_Typedef']: ## compiler/backend/common.h.py:14
    generated_code += add_code(' typedef {} {};'.format(format_type(typedef.type), typedef.name), 14)
for struct in hlir16.objects['Type_Struct']: ## compiler/backend/common.h.py:17
    # TODO make condition less arbitrary ## compiler/backend/common.h.py:18
    if not struct.name.endswith('_t'): ## compiler/backend/common.h.py:19
        continue ## compiler/backend/common.h.py:20
    generated_code += add_code(' typedef struct {}_s {{'.format(struct.name[:-2]), 21)
    for field in struct.fields: ## compiler/backend/common.h.py:23
        generated_code += add_code(' {} {};'.format(format_type(field.type), field.name), 23)
    generated_code += add_code(' }} {};'.format(struct.name), 24)
generated_code += add_code(" #endif // __COMMON_H__", 26)
