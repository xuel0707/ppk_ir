
# SPDX-License-Identifier: Apache-2.0
# Copyright 2019 Eotvos Lorand University, Budapest, Hungary

# Autogenerated file (from compiler/backend/actions.h.py), do not modify directly.
# Generator: PPK

global file_indentation_level
file_indentation_level = 0

# The last element is the innermost (current) style.
file_sugar_style = ['line_comment']


def add_code(line, lineno = None, file = "compiler/backend/actions.h.py"):
    global file_indentation_level
    global file_sugar_style
    global generated_code

    line_ends = {
        "line_comment": "\n",
        "inline_comment": "",
    }

    stripped_line = line.strip()
    no_sugar_on_line = stripped_line.startswith('//') or stripped_line.startswith('# ') or stripped_line == ""

    indent = '    ' * file_indentation_level
    return indent + line + sugar(no_sugar_on_line, file, lineno) + line_ends[file_sugar_style[-1]]


class SugarStyle():
    def __init__(self, sugar):
        global file_sugar_style
        file_sugar_style.append(sugar)

    def __enter__(self):
        global file_sugar_style
        return file_sugar_style[-1]

    def __exit__(self, type, value, traceback):
        global file_sugar_style
        file_sugar_style.pop()


def sugar(no_sugar_on_line, file, lineno):
    if no_sugar_on_line or file is None or lineno is None:
        return ""

    import re
    global file_sugar_style

    if file_sugar_style[-1] == 'line_comment':
        if no_sugar_on_line:
            return ""
        return " // {}:{}".format(file, lineno)
    if file_sugar_style[-1] == 'inline_comment':
        if file == "../compiler/backend/actions.h.py":
            return " /* {} */ {}".format(lineno)
        return " /* {}:{} */".format(file, lineno)
    return line


generated_code += "// Autogenerated file (from compiler/backend/actions.h.py via ../compiler/backend/actions.h.py), do not modify directly.\n"
generated_code += "// Generator: PPK\n"
generated_code += "\n"

# Copyright 2016 Eotvos Lorand University, Budapest, Hungary ## compiler/backend/actions.h.py:2
#  ## compiler/backend/actions.h.py:3
# Licensed under the Apache License, Version 2.0 (the "License"); ## compiler/backend/actions.h.py:4
# you may not use this file except in compliance with the License. ## compiler/backend/actions.h.py:5
# You may obtain a copy of the License at ## compiler/backend/actions.h.py:6
#  ## compiler/backend/actions.h.py:7
#     http://www.apache.org/licenses/LICENSE-2.0 ## compiler/backend/actions.h.py:8
#  ## compiler/backend/actions.h.py:9
# Unless required by applicable law or agreed to in writing, software ## compiler/backend/actions.h.py:10
# distributed under the License is distributed on an "AS IS" BASIS, ## compiler/backend/actions.h.py:11
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ## compiler/backend/actions.h.py:12
# See the License for the specific language governing permissions and ## compiler/backend/actions.h.py:13
# limitations under the License. ## compiler/backend/actions.h.py:14

generated_code += add_code("")
from utils.codegen import format_type ## compiler/backend/actions.h.py:16

generated_code += add_code("")
generated_code += add_code(" #ifndef __ACTIONS_H__", 17)
generated_code += add_code(" #define __ACTIONS_H__", 18)

generated_code += add_code("")
generated_code += add_code(" #include \"dataplane.h\"", 20)
generated_code += add_code(" #include \"common.h\"", 21)

generated_code += add_code("")
# Note: this is for Digest_t ## compiler/backend/actions.h.py:24
generated_code += add_code(" #include \"ctrl_plane_backend.h\"", 24)

generated_code += add_code("")
# TODO this should not be here in the indep section ## compiler/backend/actions.h.py:27
generated_code += add_code(" #include \"dpdk_smem.h\"", 27)

generated_code += add_code("")
generated_code += add_code(" #define FIELD(name, length) uint8_t name[(length + 7) / 8];", 29)

generated_code += add_code("")
def unique_stable(items): ## compiler/backend/actions.h.py:32
    """Returns only the first occurrence of the items in a list. ## compiler/backend/actions.h.py:33
    Equivalent to unique_everseen from Python 3.""" ## compiler/backend/actions.h.py:34
    from collections import OrderedDict ## compiler/backend/actions.h.py:35
    return list(OrderedDict.fromkeys(items)) ## compiler/backend/actions.h.py:36
generated_code += add_code(" enum actions {", 37)
for table in hlir16.tables: ## compiler/backend/actions.h.py:39
    for action in unique_stable(table.actions): ## compiler/backend/actions.h.py:40
        generated_code += add_code(' action_{},'.format(action.action_object.name), 40)
generated_code += add_code(" action_set_bitmcast,", 41)
generated_code += add_code(" action_set_clone_egress_port,", 42)
generated_code += add_code(" action_set_clone_multicast_group_id,", 43)
generated_code += add_code(" action_,", 44)
generated_code += add_code(" };", 45)

generated_code += add_code("")
for ctl in hlir16.controls: ## compiler/backend/actions.h.py:48
    for act in ctl.actions: ## compiler/backend/actions.h.py:49
        generated_code += add_code(' typedef struct action_{}_params_s {{'.format(act.name), 49)
        for param in act.parameters.parameters: ## compiler/backend/actions.h.py:51
            paramtype = param.canonical_type() ## compiler/backend/actions.h.py:52
            generated_code += add_code(' FIELD({}, {});'.format(param.name, paramtype.size), 52)
        generated_code += add_code(" FIELD(DUMMY_FIELD, 0);", 54)
        generated_code += add_code(' }} action_{}_params_t;'.format(act.name), 55)
generated_code += add_code("  typedef struct action_set_bitmcast_params_s {", 56)
generated_code += add_code("  FIELD(bit_mcast, 32); // compiler/backend/actions.h.py:52", 57)
generated_code += add_code("  FIELD(DUMMY_FIELD, 0);", 58)
generated_code += add_code("  } action_set_bitmcast_params_t;", 59)
generated_code += add_code("  typedef struct action_set_clone_egress_port_params_s {", 60)
generated_code += add_code("  FIELD(egress_port, 9);    ", 61)
generated_code += add_code("  FIELD(DUMMY_FIELD, 0);", 62)
generated_code += add_code("  } action_set_clone_egress_port_params_t;", 63)
generated_code += add_code("  typedef struct action_set_clone_multicast_group_id_params_s {", 64)
generated_code += add_code("  FIELD(multicast_group_id, 16);", 65)
generated_code += add_code("  FIELD(DUMMY_FIELD, 0);", 66)
generated_code += add_code("  } action_set_clone_multicast_group_id_params_t;", 67)

generated_code += add_code("")
generated_code += add_code(" typedef struct all_metadatas_s {", 69)
for metainst in hlir16.metadata_insts: ## compiler/backend/actions.h.py:71
    if hasattr(metainst.type, 'type_ref'): ## compiler/backend/actions.h.py:72
        for fld in metainst.type.type_ref.fields: ## compiler/backend/actions.h.py:73
            vardecl = format_type(fld.type, "field_{}_{}".format(metainst.type.type_ref.name, fld.name)) ## compiler/backend/actions.h.py:74
            generated_code += add_code(' {}; // {}, {}'.format(vardecl, metainst.type.type_ref.name, fld.name), 74)
    else: ## compiler/backend/actions.h.py:76
        # note: in the case of an array type, ## compiler/backend/actions.h.py:77
        #       the array brackets have to go after the variable name ## compiler/backend/actions.h.py:78
        varname = "metafield_" + metainst.name ## compiler/backend/actions.h.py:79
        generated_code += add_code(' {};'.format(format_type(metainst.type, varname)), 79)
generated_code += add_code(" } all_metadatas_t;", 80)

generated_code += add_code("")
for table in hlir16.tables: ## compiler/backend/actions.h.py:83
    generated_code += add_code(' struct {}_action {{'.format(table.name), 83)
    generated_code += add_code("     int action_id;", 84)
    generated_code += add_code("     union {", 85)
    for action in table.actions: ## compiler/backend/actions.h.py:87
        # TODO what if the action is not a method call? ## compiler/backend/actions.h.py:88
        # TODO what if there are more actions? ## compiler/backend/actions.h.py:89
        action_method_name = action.expression.method.ref.name ## compiler/backend/actions.h.py:90
        generated_code += add_code('         action_{}_params_t {}_params;'.format(action.action_object.name, action_method_name), 90)
    generated_code += add_code("     };", 91)
    generated_code += add_code(" };", 92)
    generated_code += add_code("", 93)
generated_code += add_code(" struct multicast_group_table_action { ", 94)
generated_code += add_code("     int action_id; ", 95)
generated_code += add_code("     union {", 96)
generated_code += add_code("         action_set_bitmcast_params_t set_bitmcast_params; ", 97)
generated_code += add_code("     }; ", 98)
generated_code += add_code(" }; ", 99)
generated_code += add_code(" struct clone_session_table_action { ", 100)
generated_code += add_code("     int action_id; ", 101)
generated_code += add_code("     union {", 102)
generated_code += add_code("         action_set_clone_egress_port_params_t set_clone_egress_port_params; ", 103)
generated_code += add_code("         action_set_clone_multicast_group_id_params_t set_clone_multicast_group_id_params; ", 104)
generated_code += add_code("     }; ", 105)
generated_code += add_code(" }; ", 106)

generated_code += add_code("")
for table in hlir16.tables: ## compiler/backend/actions.h.py:111
    generated_code += add_code(' void apply_table_{}(SHORT_STDPARAMS);'.format(table.name), 111)
    for action in table.actions: ## compiler/backend/actions.h.py:113
        aname = action.action_object.name ## compiler/backend/actions.h.py:114
        mname = action.expression.method.ref.name ## compiler/backend/actions.h.py:115
generated_code += add_code(' void action_code_{}(packet_descriptor_t *pd, packet_descriptor_t *clone_pd, lookup_table_t **tables, action_{}_params_t);'.format(aname, mname), 116)
generated_code += add_code(" void action_code_set_bitmcast(packet_descriptor_t *pd,  packet_descriptor_t *clone_pd, lookup_table_t **tables, action_set_bitmcast_params_t);", 117)
generated_code += add_code(" void action_code_set_clone_egress_port(packet_descriptor_t *pd,  packet_descriptor_t *clone_pd, lookup_table_t **tables, action_set_clone_egress_port_params_t);", 118)

generated_code += add_code("")
for ctl in hlir16.controls: ## compiler/backend/actions.h.py:121
    generated_code += add_code(' typedef struct control_locals_{}_s {{'.format(ctl.name), 121)
    for local_var_decl in ctl.controlLocals['Declaration_Variable'] + ctl.controlLocals['Declaration_Instance']: ## compiler/backend/actions.h.py:123
        if hasattr(local_var_decl.type, 'type_ref'): ## compiler/backend/actions.h.py:124
            if local_var_decl.type.type_ref.name in ['counter', 'direct_counter', 'meter']: ## compiler/backend/actions.h.py:125
                continue ## compiler/backend/actions.h.py:126
        else: ## compiler/backend/actions.h.py:127
            if local_var_decl.type('baseType.type_ref.name', lambda n: n in ['direct_meter', 'register']): ## compiler/backend/actions.h.py:128
                continue ## compiler/backend/actions.h.py:129
        postfix = "_t" if local_var_decl.type.node_type == 'Type_Name' else "" ## compiler/backend/actions.h.py:131
        generated_code += add_code(' {}{} {};'.format(format_type(local_var_decl.type, resolve_names = False), postfix, local_var_decl.name), 131)
    # TODO is there a more appropriate way to store registers? ## compiler/backend/actions.h.py:134
    for reg in hlir16.registers: ## compiler/backend/actions.h.py:135
        generated_code += add_code(' {} {};'.format(format_type(reg.type, resolve_names = False), reg.name), 135)
    generated_code += add_code(' }} control_locals_{}_t;'.format(ctl.name), 137)
generated_code += add_code(" #endif", 139)
