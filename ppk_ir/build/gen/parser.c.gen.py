
# SPDX-License-Identifier: Apache-2.0
# Copyright 2019 Eotvos Lorand University, Budapest, Hungary

# Autogenerated file (from compiler/backend/parser.c.py), do not modify directly.
# Generator: PPK

global file_indentation_level
file_indentation_level = 0

# The last element is the innermost (current) style.
file_sugar_style = ['line_comment']


def add_code(line, lineno = None, file = "compiler/backend/parser.c.py"):
    global file_indentation_level
    global file_sugar_style
    global generated_code

    line_ends = {
        "line_comment": "\n",
        "inline_comment": "",
    }

    stripped_line = line.strip()
    no_sugar_on_line = stripped_line.startswith('//') or stripped_line.startswith('# ') or stripped_line == ""

    indent = '    ' * file_indentation_level
    return indent + line + sugar(no_sugar_on_line, file, lineno) + line_ends[file_sugar_style[-1]]


class SugarStyle():
    def __init__(self, sugar):
        global file_sugar_style
        file_sugar_style.append(sugar)

    def __enter__(self):
        global file_sugar_style
        return file_sugar_style[-1]

    def __exit__(self, type, value, traceback):
        global file_sugar_style
        file_sugar_style.pop()


def sugar(no_sugar_on_line, file, lineno):
    if no_sugar_on_line or file is None or lineno is None:
        return ""

    import re
    global file_sugar_style

    if file_sugar_style[-1] == 'line_comment':
        if no_sugar_on_line:
            return ""
        return " // {}:{}".format(file, lineno)
    if file_sugar_style[-1] == 'inline_comment':
        if file == "../compiler/backend/parser.c.py":
            return " /* {} */ {}".format(lineno)
        return " /* {}:{} */".format(file, lineno)
    return line


generated_code += "// Autogenerated file (from compiler/backend/parser.c.py via ../compiler/backend/parser.c.py), do not modify directly.\n"
generated_code += "// Generator: PPK\n"
generated_code += "\n"

# Copyright 2016 Eotvos Lorand University, Budapest, Hungary ## compiler/backend/parser.c.py:2
#  ## compiler/backend/parser.c.py:3
# Licensed under the Apache License, Version 2.0 (the "License"); ## compiler/backend/parser.c.py:4
# you may not use this file except in compliance with the License. ## compiler/backend/parser.c.py:5
# You may obtain a copy of the License at ## compiler/backend/parser.c.py:6
#  ## compiler/backend/parser.c.py:7
#     http://www.apache.org/licenses/LICENSE-2.0 ## compiler/backend/parser.c.py:8
#  ## compiler/backend/parser.c.py:9
# Unless required by applicable law or agreed to in writing, software ## compiler/backend/parser.c.py:10
# distributed under the License is distributed on an "AS IS" BASIS, ## compiler/backend/parser.c.py:11
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ## compiler/backend/parser.c.py:12
# See the License for the specific language governing permissions and ## compiler/backend/parser.c.py:13
# limitations under the License. ## compiler/backend/parser.c.py:14

generated_code += add_code("")
from utils.misc import addError, addWarning  ## compiler/backend/parser.c.py:16
from utils.codegen import format_expr, format_statement, statement_buffer_value, format_declaration ## compiler/backend/parser.c.py:17

generated_code += add_code("")
generated_code += add_code(" #include \"dpdk_lib.h\"", 19)
generated_code += add_code(" #include \"util_packet.h\"", 20)

generated_code += add_code("")
generated_code += add_code(" uint16_t lkahead_data;", 22)
generated_code += add_code(" void packet_in_t_lookahead(packet_descriptor_t* pd, int len, uint8_t* in_buf) {", 23)
generated_code += add_code("    memcpy(&lkahead_data, in_buf, len/8);", 24)
generated_code += add_code(" }", 25)

generated_code += add_code("")
generated_code += add_code(" extern int get_var_width_bitwidth();", 27)

generated_code += add_code("")
def header_bit_width(hdrtype): ## compiler/backend/parser.c.py:30
    return sum([f.size if not f.is_vw else 0 for f in hdrtype.fields]) ## compiler/backend/parser.c.py:31
def gen_extract_header_tmp(h): ## compiler/backend/parser.c.py:33
    generated_code = ""
    generated_code += add_code(' memcpy(pstate->{}, buf, {});'.format(h.ref.name, h.type.byte_width), 33)
    generated_code += add_code(' buf += {};'.format(h.type.byte_width), 34)
    generated_code += add_code(' pd->parsed_length += {};'.format(h.type.byte_width), 35)
    return generated_code
def gen_extract_header_tmp_2(hdrinst, hdrtype, w): ## compiler/backend/parser.c.py:38
    generated_code = ""
    x = header_bit_width(hdrtype) ## compiler/backend/parser.c.py:39
    w = format_expr(w) ## compiler/backend/parser.c.py:40
    generated_code += add_code(' int hdrlen = (({}+{})/8);'.format(w, x), 40)
    generated_code += add_code(" pd->parsed_length += hdrlen;", 41)
    generated_code += add_code(' memcpy(pstate->{}, buf, hdrlen);'.format(hdrinst.ref.name), 42)
    generated_code += add_code(' pstate->{}_var += {}+{};'.format(hdrinst.ref.name, w, x), 43)
    generated_code += add_code(" buf += hdrlen;", 44)
    return generated_code
def gen_extract_header(hdrinst, hdrtype, arg0_expr): ## compiler/backend/parser.c.py:48
    generated_code = ""
    if hdrinst is None: ## compiler/backend/parser.c.py:49
        addError("extracting header", "no instance found for header type " + hdrtype.name) ## compiler/backend/parser.c.py:50
        return generated_code ## compiler/backend/parser.c.py:51
    if hasattr(arg0_expr, "path"): ## compiler/backend/parser.c.py:53
        hdrname = arg0_expr.path.name ## compiler/backend/parser.c.py:54
    else: ## compiler/backend/parser.c.py:55
        hdrname = hdrinst.name ## compiler/backend/parser.c.py:56
    generated_code += add_code(' if(unlikely((int)((uint8_t*)buf-(uint8_t*)(pd->data))+{} > pd->wrapper->pkt_len))'.format(hdrtype.byte_width), 57)
    generated_code += add_code("     ; // packet_too_short // TODO optimize this", 58)
    generated_code += add_code(' pd->headers[header_instance_{}].pointer = buf;'.format(hdrname), 59)
    generated_code += add_code(' pd->headers[header_instance_{}].was_enabled_at_initial_parse = true;'.format(hdrname), 60)
    generated_code += add_code(' pd->headers[header_instance_{}].length = {};'.format(hdrname, hdrtype.byte_width), 61)
    generated_code += add_code(' pd->parsed_length += {};'.format(hdrtype.byte_width), 62)
    for f in hdrtype.fields: ## compiler/backend/parser.c.py:64
        # TODO get rid of "f.get_attr('preparsed') is not None" ## compiler/backend/parser.c.py:65
        # TODO (f must always have a preparsed attribute) ## compiler/backend/parser.c.py:66
        if f.get_attr('preparsed') is not None and f.preparsed and f.size <= 32: ## compiler/backend/parser.c.py:67
            generated_code += add_code(' EXTRACT_INT32_AUTO_PACKET(pd, {}, {}, value32)'.format(hdrinst.id, f.id), 67)
            generated_code += add_code(' pd->fields.{} = value32;'.format(f.id), 68)
            generated_code += add_code(' pd->fields.attr_{} = 0;'.format(f.id), 69)
    generated_code += add_code(' buf += {};'.format(hdrtype.byte_width), 70)
    return generated_code
def gen_extract_header_var_width(hdrinst, hdrtype, width_expr): ## compiler/backend/parser.c.py:73
    generated_code = ""
    if not hdrtype.is_vw: ## compiler/backend/parser.c.py:74
        addError("generating extract header call", "fixed-width header extracted with two-param extract") ## compiler/backend/parser.c.py:75
        return generated_code ## compiler/backend/parser.c.py:76
    x = header_bit_width(hdrtype) ## compiler/backend/parser.c.py:78
    generated_code += add_code(' uint32_t hdrlen = (({}+{})/8);'.format(format_expr(width_expr), x), 79)
    generated_code += add_code(" if (unlikely((int)((uint8_t*)buf-(uint8_t*)(pd->data))+hdrlen > pd->wrapper->pkt_len))", 80)
    generated_code += add_code("     ; // packet_too_short // TODO optimize this", 81)
    generated_code += add_code(' if (hdrlen > {})'.format(hdrtype.byte_width), 82)
    generated_code += add_code('     debug("    " T4LIT(!,warning) " variable width header " T4LIT({},header) " is " T4LIT(too long,warning) " (" T4LIT(%d,warning) " bytes)\\n", hdrlen);'.format(hdrinst.name), 83)
    generated_code += add_code(' pd->headers[{}].pointer = buf;'.format(hdrinst.id), 84)
    generated_code += add_code(' pd->headers[{}].was_enabled_at_initial_parse = true;'.format(hdrinst.id), 85)
    generated_code += add_code(' pd->headers[{}].length = hdrlen;'.format(hdrinst.id), 86)
    generated_code += add_code(" pd->parsed_length += hdrlen;", 87)
    generated_code += add_code(' pd->headers[{}].var_width_field_bitwidth = hdrlen * 8 - {};'.format(hdrinst.id, header_bit_width(hdrtype)), 88)
    generated_code += add_code(" buf += hdrlen;", 89)
    return generated_code
################################################################################ ## compiler/backend/parser.c.py:93

generated_code += add_code("")
# TODO more than one parser can be present ## compiler/backend/parser.c.py:95
parser = hlir16.objects['P4Parser'][0] ## compiler/backend/parser.c.py:96

generated_code += add_code("")
generated_code += add_code(" void init_parser_state(parser_state_t* pstate) {", 97)
for l in parser.parserLocals: ## compiler/backend/parser.c.py:99
    if l.node_type == 'Declaration_Instance': ## compiler/backend/parser.c.py:100
        generated_code += add_code(' {}_t_init(pstate->{});'.format(l.type.type_ref.name, l.name), 100)
generated_code += add_code(" }", 101)

generated_code += add_code("")
for s in parser.states: ## compiler/backend/parser.c.py:104
    generated_code += add_code(' static void parser_state_{}(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate);'.format(s.name), 104)
for s in parser.states: ## compiler/backend/parser.c.py:107
    generated_code += add_code(' static void parser_state_{}(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) {{'.format(s.name), 107)
    generated_code += add_code("     uint32_t value32; (void)value32;", 108)
    generated_code += add_code("     uint32_t res32; (void)res32;", 109)
    generated_code += add_code("     parser_state_t* local_vars = pstate;", 110)
    generated_code += add_code("     uint8_t* buf = in_buf;", 111)
    generated_code += add_code('     debug(" :::: Parser state " T4LIT({},parserstate) "\\n");'.format(s.name), 112)
    for c in s.components: ## compiler/backend/parser.c.py:114
        if not hasattr(c, 'call'): ## compiler/backend/parser.c.py:115
            generated_code += add_code(' {}'.format(format_statement(c, parser)), 115)
            continue ## compiler/backend/parser.c.py:117
        if c.call != 'extract_header': ## compiler/backend/parser.c.py:119
            continue ## compiler/backend/parser.c.py:120
        generated_code += add_code(' // Extracting header {}'.format(s.name), 121)
        hdrtype = c.header.type_ref if hasattr(c.header, 'type_ref') else c.header ## compiler/backend/parser.c.py:124
        arg0_expr = c.methodCall.arguments['Argument'][0] ## compiler/backend/parser.c.py:126
        # TODO find a more universal way to get to the header instance ## compiler/backend/parser.c.py:128
        if hasattr(arg0_expr, 'path'): ## compiler/backend/parser.c.py:129
            hdrinst_name = arg0_expr.path.name ## compiler/backend/parser.c.py:130
            dvar = parser.parserLocals.get(hdrinst_name, 'Declaration_Variable') ## compiler/backend/parser.c.py:132
            if dvar: ## compiler/backend/parser.c.py:133
                insts = [hi for hi in hlir16.header_instances['StructField'] if hi.type.type_ref.name == hdrtype.name] ## compiler/backend/parser.c.py:134
                if len(insts) == 1: ## compiler/backend/parser.c.py:135
                    hdrinst = insts[0] ## compiler/backend/parser.c.py:136
                elif len(insts) == 0: ## compiler/backend/parser.c.py:137
                    # note: it is defined as a local variable ## compiler/backend/parser.c.py:138
                    hdrinst = dvar.type.type_ref ## compiler/backend/parser.c.py:139
                else: ## compiler/backend/parser.c.py:140
                    addError("Finding header instance", "There is no single header instance that corresponds to {}".format(hdrtype.name)) ## compiler/backend/parser.c.py:141
                hdrtype = dvar.type.type_ref ## compiler/backend/parser.c.py:143
            else: ## compiler/backend/parser.c.py:144
                hdrinst = hlir16.header_instances.get(hdrinst_name, 'Declaration_Variable', lambda hi: hi.type.type_ref.name == hdrtype.name) ## compiler/backend/parser.c.py:145
            pstate_var_name = dvar.name ## compiler/backend/parser.c.py:147
        elif hasattr(c.methodCall.method.expr, 'header_ref'): ## compiler/backend/parser.c.py:148
            hdrinst = c.methodCall.method.expr.header_ref ## compiler/backend/parser.c.py:149
            pstate_var_name = hdrinst.name ## compiler/backend/parser.c.py:150
        else: ## compiler/backend/parser.c.py:151
            arg0_expr = c.methodCall.arguments[0].expression ## compiler/backend/parser.c.py:152
            if hasattr(arg0_expr, "member"): ## compiler/backend/parser.c.py:153
                hdrinst_name = arg0_expr.member ## compiler/backend/parser.c.py:154
                hdrinst = hlir16.header_instances.get(hdrinst_name, 'StructField', lambda hi: hi.type.type_ref.name == hdrtype.name) ## compiler/backend/parser.c.py:155
            else: ## compiler/backend/parser.c.py:156
                hdrinst_name = arg0_expr.path.name ## compiler/backend/parser.c.py:157
                hdrinst = hlir16.header_instances.get(hdrinst_name) ## compiler/backend/parser.c.py:158
            pstate_var_name = hdrinst.name ## compiler/backend/parser.c.py:159
        # TODO there should be no "secondary" hdrtype node ## compiler/backend/parser.c.py:161
        if not hasattr(hdrtype, 'bit_width'): ## compiler/backend/parser.c.py:162
            hdrtype = hlir16.header_types.get(hdrtype.name, 'Type_Header') ## compiler/backend/parser.c.py:163
        bitwidth = hdrtype.bit_width if not c.is_vw else header_bit_width(hdrtype) ## compiler/backend/parser.c.py:165
        if not c.is_tmp: ## compiler/backend/parser.c.py:167
            if not c.is_vw: ## compiler/backend/parser.c.py:168
                generated_code += add_code(' {}'.format(gen_extract_header(hdrinst, hdrtype, arg0_expr)), 168)
            else: ## compiler/backend/parser.c.py:170
                generated_code += add_code(' {}'.format(gen_extract_header_var_width(hdrinst, hdrtype, c.width)), 170)
                # the variable counts in bytes, length in bits, hence the multiplication by 8 ## compiler/backend/parser.c.py:173
            generated_code += add_code(' dbg_bytes(pd->headers[{}].pointer, pd->headers[{}].length,'.format(hdrinst.id, hdrinst.id), 173)
            generated_code += add_code('           "   :: Extracted {}header instance " T4LIT(#%d) " " T4LIT({},header) "/" T4LIT(%d) "B: ", {} + 1, pd->headers[{}].length);'.format("variable width " if c.is_vw else "", hdrinst.name, hdrinst.id, hdrinst.id), 174)
            generated_code += add_code("  #if PPK_VLAN", 175)
            generated_code += add_code('     if (strcmp("{}", "parse_ethernet") == 0) {{'.format(s.name), 176)
            generated_code += add_code("       uint32_t* tmp = (uint32_t*)buf;   ", 177)
            generated_code += add_code("       uint32_t vlan1 = *tmp;", 178)
            generated_code += add_code("       uint32_t vlan = rte_cpu_to_be_32(vlan1);", 179)
            generated_code += add_code("       uint16_t vlanid = (uint16_t)(vlan >> 16) & 0x0fff;", 180)
            generated_code += add_code("       uint16_t vlantype = rte_cpu_to_be_16((uint16_t)(vlan)) &0xffff;", 181)
            generated_code += add_code("       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_instance_type, vlantype);", 182)
            generated_code += add_code("       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_ethernet, field_ethernet_t_ether_type, vlantype);", 183)
            generated_code += add_code("       int ingress_port_value = vlanid - 1000;", 184)
            generated_code += add_code("       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port, ingress_port_value);", 185)
            generated_code += add_code("       debug(\"       v1model :value of ingress vlan field  \" T4LIT(%08x) \"\\n\",GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port));", 186)
            generated_code += add_code("       pd->parsed_length += 4;", 187)
            generated_code += add_code("       buf += 4;", 188)
            generated_code += add_code("     }", 189)
            generated_code += add_code("  #endif", 190)
        else: ## compiler/backend/parser.c.py:192
            if not c.is_vw: ## compiler/backend/parser.c.py:193
                generated_code += add_code(' {}'.format(gen_extract_header_tmp(hdrinst)), 193)
                generated_code += add_code(' dbg_bytes(pstate->{}, {},'.format(hdrinst.ref.name, hdrtype.byte_width), 194)
                generated_code += add_code('           "   :: Extracted header instance " T4LIT(#%d) " " T4LIT({},header) " of type " T4LIT({}) "/" T4LIT({}) "B: ", {} + 1, pd->headers[{}].length);'.format(hdrinst.path.name, hdrinst.type.name, hdrtype.byte_width, hdrinst.id, hdrinst.id), 195)
            else: ## compiler/backend/parser.c.py:198
                generated_code += add_code(' {}'.format(gen_extract_header_tmp_2(hdrinst, hdrtype, c.width)), 198)
                hdr_width = header_bit_width(hdrtype) ## compiler/backend/parser.c.py:200
                var_width = format_expr(c.width) ## compiler/backend/parser.c.py:201
                generated_code += add_code(' dbg_bytes(pstate->{}, (({} + {})+7)/8,'.format(hdrinst.ref.name, hdr_width, var_width), 201)
                generated_code += add_code('           "   :: Extracted header instance " T4LIT(#%d) " " T4LIT({},header) " of type " T4LIT({}) "/" T4LIT(%d) "B: ",'.format(hdrinst.path.name, hdrtype.name), 202)
                generated_code += add_code('           {} + 1, (({} + {})+7)/8);'.format(hdrinst.id, hdr_width, var_width), 203)
    if not hasattr(s, 'selectExpression'): ## compiler/backend/parser.c.py:206
        if s.name == 'accept': ## compiler/backend/parser.c.py:207
            generated_code += add_code(' debug("   :: Packet is " T4LIT(accepted,success) "\\n");', 207)
            generated_code += add_code(" pd->payload_length = packet_length(pd) - pd->parsed_length;", 208)
            generated_code += add_code(" if (pd->payload_length > 0) {", 210)
            generated_code += add_code('     dbg_bytes(pd->data + pd->parsed_length, pd->payload_length, "    : " T4LIT(Payload,header) " is " T4LIT(%d) " bytes: ", pd->payload_length);', 211)
            generated_code += add_code(" } else {", 212)
            generated_code += add_code("     debug(\"    : \" T4LIT(Payload,header) \" is empty\\n\");", 213)
            generated_code += add_code(" }", 214)
        if s.name == 'reject': ## compiler/backend/parser.c.py:216
            generated_code += add_code(' debug("   :: Packet is " T4LIT(dropped,status) "\\n");', 216)
            generated_code += add_code("     MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_drop, true);", 217)
    else: ## compiler/backend/parser.c.py:219
        b = s.selectExpression ## compiler/backend/parser.c.py:220
        bexpr = format_expr(b) ## compiler/backend/parser.c.py:221
        prebuf, postbuf = statement_buffer_value() ## compiler/backend/parser.c.py:222
        generated_code += add_code(' {}'.format(prebuf), 223)
        if b.node_type == 'PathExpression': ## compiler/backend/parser.c.py:225
            generated_code += add_code(' parser_state_{}(pd, buf, tables, pstate);'.format(bexpr), 225)
        elif b.node_type == 'SelectExpression': ## compiler/backend/parser.c.py:227
            generated_code += str( bexpr) ## compiler/backend/parser.c.py:227
        generated_code += add_code(' {}'.format(postbuf), 228)
    generated_code += add_code(" }", 229)
generated_code += add_code(" void parse_packet(packet_descriptor_t* pd, lookup_table_t** tables, parser_state_t* pstate) {", 231)
generated_code += add_code("     parser_state_start(pd, pd->data, tables, pstate);", 232)
generated_code += add_code(" }", 233)

generated_code += add_code("")
generated_code += add_code(" const char* header_instance_names[HEADER_INSTANCE_COUNT] = {", 236)
for hdr in hlir16.header_instances: ## compiler/backend/parser.c.py:238
    generated_code += add_code(' "{}", // header_instance_{}'.format(hdr.name, hdr.name), 238)
generated_code += add_code(" };", 239)

generated_code += add_code("")
generated_code += add_code(" const char* field_names[FIELD_COUNT] = {", 241)
for hdr in hlir16.header_types: ## compiler/backend/parser.c.py:243
    for fld in hdr.fields: ## compiler/backend/parser.c.py:244
        generated_code += add_code(' "{}", // field_instance_{}_{}'.format(fld.name, hdr.name, fld.name), 244)
generated_code += add_code(" };", 245)

generated_code += add_code("")
generated_code += add_code(" // Returns the sum of all collected variable widths.", 248)
generated_code += add_code(" int get_var_width_bitwidth(parser_state_t* pstate) {", 249)
generated_code += add_code("     int retval = 0", 250)
for loc in parser.parserLocals: ## compiler/backend/parser.c.py:252
    generated_code += add_code(' + pstate->{}'.format(loc.name), 252)
generated_code += add_code("     ;", 253)

generated_code += add_code("")
generated_code += add_code(" return retval;", 255)

generated_code += add_code("")
generated_code += add_code(" }", 257)
