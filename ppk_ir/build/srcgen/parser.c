// Autogenerated file (from compiler/backend/parser.c.py via ../compiler/backend/parser.c.py), do not modify directly.
// Generator: PPK

 #include "dpdk_lib.h" // compiler/backend/parser.c.py:19
 #include "util_packet.h" // compiler/backend/parser.c.py:20

 uint16_t lkahead_data; // compiler/backend/parser.c.py:22
 void packet_in_t_lookahead(packet_descriptor_t* pd, int len, uint8_t* in_buf) { // compiler/backend/parser.c.py:23
    memcpy(&lkahead_data, in_buf, len/8); // compiler/backend/parser.c.py:24
 } // compiler/backend/parser.c.py:25

 extern int get_var_width_bitwidth(); // compiler/backend/parser.c.py:27

 void init_parser_state(parser_state_t* pstate) { // compiler/backend/parser.c.py:97
 } // compiler/backend/parser.c.py:101

 static void parser_state_start(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_parse_ethernet(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_parse_mf(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_parse_geo(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_parse_beacon(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_parse_gbc(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_parse_btp(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_parse_its(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_parse_tsb(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_accept(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_reject(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate); // compiler/backend/parser.c.py:104
 static void parser_state_start(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(start,parserstate) "\n"); // compiler/backend/parser.c.py:112
 
 parser_state_parse_ethernet(pd, buf, tables, pstate); // compiler/backend/parser.c.py:225
 
 } // compiler/backend/parser.c.py:229
 static void parser_state_parse_ethernet(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(parse_ethernet,parserstate) "\n"); // compiler/backend/parser.c.py:112
 // Extracting header parse_ethernet
  if(unlikely((int)((uint8_t*)buf-(uint8_t*)(pd->data))+14 > pd->wrapper->pkt_len)) // compiler/backend/parser.c.py:57
     ; // packet_too_short // TODO optimize this // compiler/backend/parser.c.py:58
 pd->headers[header_instance_ethernet].pointer = buf; // compiler/backend/parser.c.py:59
 pd->headers[header_instance_ethernet].was_enabled_at_initial_parse = true; // compiler/backend/parser.c.py:60
 pd->headers[header_instance_ethernet].length = 14; // compiler/backend/parser.c.py:61
 pd->parsed_length += 14; // compiler/backend/parser.c.py:62
 buf += 14; // compiler/backend/parser.c.py:70
 // compiler/backend/parser.c.py:168
 dbg_bytes(pd->headers[header_instance_ethernet].pointer, pd->headers[header_instance_ethernet].length, // compiler/backend/parser.c.py:173
           "   :: Extracted header instance " T4LIT(#%d) " " T4LIT(ethernet,header) "/" T4LIT(%d) "B: ", header_instance_ethernet + 1, pd->headers[header_instance_ethernet].length); // compiler/backend/parser.c.py:174
  #if PPK_VLAN // compiler/backend/parser.c.py:175
     if (strcmp("parse_ethernet", "parse_ethernet") == 0) { // compiler/backend/parser.c.py:176
       uint32_t* tmp = (uint32_t*)buf;    // compiler/backend/parser.c.py:177
       uint32_t vlan1 = *tmp; // compiler/backend/parser.c.py:178
       uint32_t vlan = rte_cpu_to_be_32(vlan1); // compiler/backend/parser.c.py:179
       uint16_t vlanid = (uint16_t)(vlan >> 16) & 0x0fff; // compiler/backend/parser.c.py:180
       uint16_t vlantype = rte_cpu_to_be_16((uint16_t)(vlan)) &0xffff; // compiler/backend/parser.c.py:181
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_instance_type, vlantype); // compiler/backend/parser.c.py:182
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_ethernet, field_ethernet_t_ether_type, vlantype); // compiler/backend/parser.c.py:183
       int ingress_port_value = vlanid - 1000; // compiler/backend/parser.c.py:184
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port, ingress_port_value); // compiler/backend/parser.c.py:185
       debug("       v1model :value of ingress vlan field  " T4LIT(%08x) "\n",GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port)); // compiler/backend/parser.c.py:186
       pd->parsed_length += 4; // compiler/backend/parser.c.py:187
       buf += 4; // compiler/backend/parser.c.py:188
     } // compiler/backend/parser.c.py:189
  #endif // compiler/backend/parser.c.py:190
 
 uint16_t  value_Member_369842 /* compiler/utils/codegen.sugar.py:1394 */ = (GET_INT32_AUTO_PACKET(pd, header_instance_ethernet, field_ethernet_t_etherType)); // (prepended) compiler/utils/codegen.sugar.py:1089
 // compiler/backend/parser.c.py:223
if( value_Member_369842 /* compiler/utils/codegen.sugar.py:1394 */ == (uint16_t)0x27c0){parser_state_parse_mf(pd, buf, tables, pstate);}
else
if( value_Member_369842 /* compiler/utils/codegen.sugar.py:1394 */ == (uint16_t)0x8947 /* probably -30393 */){parser_state_parse_geo(pd, buf, tables, pstate);}
else
if(true /* default */){parser_state_accept(pd, buf, tables, pstate);} 
 } // compiler/backend/parser.c.py:229
 static void parser_state_parse_mf(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(parse_mf,parserstate) "\n"); // compiler/backend/parser.c.py:112
 // Extracting header parse_mf
  if(unlikely((int)((uint8_t*)buf-(uint8_t*)(pd->data))+12 > pd->wrapper->pkt_len)) // compiler/backend/parser.c.py:57
     ; // packet_too_short // TODO optimize this // compiler/backend/parser.c.py:58
 pd->headers[header_instance_mf].pointer = buf; // compiler/backend/parser.c.py:59
 pd->headers[header_instance_mf].was_enabled_at_initial_parse = true; // compiler/backend/parser.c.py:60
 pd->headers[header_instance_mf].length = 12; // compiler/backend/parser.c.py:61
 pd->parsed_length += 12; // compiler/backend/parser.c.py:62
 buf += 12; // compiler/backend/parser.c.py:70
 // compiler/backend/parser.c.py:168
 dbg_bytes(pd->headers[header_instance_mf].pointer, pd->headers[header_instance_mf].length, // compiler/backend/parser.c.py:173
           "   :: Extracted header instance " T4LIT(#%d) " " T4LIT(mf,header) "/" T4LIT(%d) "B: ", header_instance_mf + 1, pd->headers[header_instance_mf].length); // compiler/backend/parser.c.py:174
  #if PPK_VLAN // compiler/backend/parser.c.py:175
     if (strcmp("parse_mf", "parse_ethernet") == 0) { // compiler/backend/parser.c.py:176
       uint32_t* tmp = (uint32_t*)buf;    // compiler/backend/parser.c.py:177
       uint32_t vlan1 = *tmp; // compiler/backend/parser.c.py:178
       uint32_t vlan = rte_cpu_to_be_32(vlan1); // compiler/backend/parser.c.py:179
       uint16_t vlanid = (uint16_t)(vlan >> 16) & 0x0fff; // compiler/backend/parser.c.py:180
       uint16_t vlantype = rte_cpu_to_be_16((uint16_t)(vlan)) &0xffff; // compiler/backend/parser.c.py:181
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_instance_type, vlantype); // compiler/backend/parser.c.py:182
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_ethernet, field_ethernet_t_ether_type, vlantype); // compiler/backend/parser.c.py:183
       int ingress_port_value = vlanid - 1000; // compiler/backend/parser.c.py:184
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port, ingress_port_value); // compiler/backend/parser.c.py:185
       debug("       v1model :value of ingress vlan field  " T4LIT(%08x) "\n",GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port)); // compiler/backend/parser.c.py:186
       pd->parsed_length += 4; // compiler/backend/parser.c.py:187
       buf += 4; // compiler/backend/parser.c.py:188
     } // compiler/backend/parser.c.py:189
  #endif // compiler/backend/parser.c.py:190
 
 parser_state_accept(pd, buf, tables, pstate); // compiler/backend/parser.c.py:225
 
 } // compiler/backend/parser.c.py:229
 static void parser_state_parse_geo(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(parse_geo,parserstate) "\n"); // compiler/backend/parser.c.py:112
 // Extracting header parse_geo
  if(unlikely((int)((uint8_t*)buf-(uint8_t*)(pd->data))+12 > pd->wrapper->pkt_len)) // compiler/backend/parser.c.py:57
     ; // packet_too_short // TODO optimize this // compiler/backend/parser.c.py:58
 pd->headers[header_instance_geo].pointer = buf; // compiler/backend/parser.c.py:59
 pd->headers[header_instance_geo].was_enabled_at_initial_parse = true; // compiler/backend/parser.c.py:60
 pd->headers[header_instance_geo].length = 12; // compiler/backend/parser.c.py:61
 pd->parsed_length += 12; // compiler/backend/parser.c.py:62
 buf += 12; // compiler/backend/parser.c.py:70
 // compiler/backend/parser.c.py:168
 dbg_bytes(pd->headers[header_instance_geo].pointer, pd->headers[header_instance_geo].length, // compiler/backend/parser.c.py:173
           "   :: Extracted header instance " T4LIT(#%d) " " T4LIT(geo,header) "/" T4LIT(%d) "B: ", header_instance_geo + 1, pd->headers[header_instance_geo].length); // compiler/backend/parser.c.py:174
  #if PPK_VLAN // compiler/backend/parser.c.py:175
     if (strcmp("parse_geo", "parse_ethernet") == 0) { // compiler/backend/parser.c.py:176
       uint32_t* tmp = (uint32_t*)buf;    // compiler/backend/parser.c.py:177
       uint32_t vlan1 = *tmp; // compiler/backend/parser.c.py:178
       uint32_t vlan = rte_cpu_to_be_32(vlan1); // compiler/backend/parser.c.py:179
       uint16_t vlanid = (uint16_t)(vlan >> 16) & 0x0fff; // compiler/backend/parser.c.py:180
       uint16_t vlantype = rte_cpu_to_be_16((uint16_t)(vlan)) &0xffff; // compiler/backend/parser.c.py:181
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_instance_type, vlantype); // compiler/backend/parser.c.py:182
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_ethernet, field_ethernet_t_ether_type, vlantype); // compiler/backend/parser.c.py:183
       int ingress_port_value = vlanid - 1000; // compiler/backend/parser.c.py:184
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port, ingress_port_value); // compiler/backend/parser.c.py:185
       debug("       v1model :value of ingress vlan field  " T4LIT(%08x) "\n",GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port)); // compiler/backend/parser.c.py:186
       pd->parsed_length += 4; // compiler/backend/parser.c.py:187
       buf += 4; // compiler/backend/parser.c.py:188
     } // compiler/backend/parser.c.py:189
  #endif // compiler/backend/parser.c.py:190
 
 uint8_t  value_Member_369911 /* compiler/utils/codegen.sugar.py:1394 */ = (GET_INT32_AUTO_PACKET(pd, header_instance_geo, field_geo_t_ht)); // (prepended) compiler/utils/codegen.sugar.py:1089
 // compiler/backend/parser.c.py:223
if( value_Member_369911 /* compiler/utils/codegen.sugar.py:1394 */ == (uint8_t)0x1){parser_state_parse_beacon(pd, buf, tables, pstate);}
else
if( value_Member_369911 /* compiler/utils/codegen.sugar.py:1394 */ == (uint8_t)0x4){parser_state_parse_gbc(pd, buf, tables, pstate);}
else
if( value_Member_369911 /* compiler/utils/codegen.sugar.py:1394 */ == (uint8_t)0x5){parser_state_parse_tsb(pd, buf, tables, pstate);}
else
if(true /* default */){parser_state_accept(pd, buf, tables, pstate);} 
 } // compiler/backend/parser.c.py:229
 static void parser_state_parse_beacon(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(parse_beacon,parserstate) "\n"); // compiler/backend/parser.c.py:112
 // Extracting header parse_beacon
  if(unlikely((int)((uint8_t*)buf-(uint8_t*)(pd->data))+24 > pd->wrapper->pkt_len)) // compiler/backend/parser.c.py:57
     ; // packet_too_short // TODO optimize this // compiler/backend/parser.c.py:58
 pd->headers[header_instance_beacon].pointer = buf; // compiler/backend/parser.c.py:59
 pd->headers[header_instance_beacon].was_enabled_at_initial_parse = true; // compiler/backend/parser.c.py:60
 pd->headers[header_instance_beacon].length = 24; // compiler/backend/parser.c.py:61
 pd->parsed_length += 24; // compiler/backend/parser.c.py:62
 buf += 24; // compiler/backend/parser.c.py:70
 // compiler/backend/parser.c.py:168
 dbg_bytes(pd->headers[header_instance_beacon].pointer, pd->headers[header_instance_beacon].length, // compiler/backend/parser.c.py:173
           "   :: Extracted header instance " T4LIT(#%d) " " T4LIT(beacon,header) "/" T4LIT(%d) "B: ", header_instance_beacon + 1, pd->headers[header_instance_beacon].length); // compiler/backend/parser.c.py:174
  #if PPK_VLAN // compiler/backend/parser.c.py:175
     if (strcmp("parse_beacon", "parse_ethernet") == 0) { // compiler/backend/parser.c.py:176
       uint32_t* tmp = (uint32_t*)buf;    // compiler/backend/parser.c.py:177
       uint32_t vlan1 = *tmp; // compiler/backend/parser.c.py:178
       uint32_t vlan = rte_cpu_to_be_32(vlan1); // compiler/backend/parser.c.py:179
       uint16_t vlanid = (uint16_t)(vlan >> 16) & 0x0fff; // compiler/backend/parser.c.py:180
       uint16_t vlantype = rte_cpu_to_be_16((uint16_t)(vlan)) &0xffff; // compiler/backend/parser.c.py:181
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_instance_type, vlantype); // compiler/backend/parser.c.py:182
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_ethernet, field_ethernet_t_ether_type, vlantype); // compiler/backend/parser.c.py:183
       int ingress_port_value = vlanid - 1000; // compiler/backend/parser.c.py:184
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port, ingress_port_value); // compiler/backend/parser.c.py:185
       debug("       v1model :value of ingress vlan field  " T4LIT(%08x) "\n",GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port)); // compiler/backend/parser.c.py:186
       pd->parsed_length += 4; // compiler/backend/parser.c.py:187
       buf += 4; // compiler/backend/parser.c.py:188
     } // compiler/backend/parser.c.py:189
  #endif // compiler/backend/parser.c.py:190
 
 parser_state_accept(pd, buf, tables, pstate); // compiler/backend/parser.c.py:225
 
 } // compiler/backend/parser.c.py:229
 static void parser_state_parse_gbc(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(parse_gbc,parserstate) "\n"); // compiler/backend/parser.c.py:112
 // Extracting header parse_gbc
  if(unlikely((int)((uint8_t*)buf-(uint8_t*)(pd->data))+44 > pd->wrapper->pkt_len)) // compiler/backend/parser.c.py:57
     ; // packet_too_short // TODO optimize this // compiler/backend/parser.c.py:58
 pd->headers[header_instance_gbc].pointer = buf; // compiler/backend/parser.c.py:59
 pd->headers[header_instance_gbc].was_enabled_at_initial_parse = true; // compiler/backend/parser.c.py:60
 pd->headers[header_instance_gbc].length = 44; // compiler/backend/parser.c.py:61
 pd->parsed_length += 44; // compiler/backend/parser.c.py:62
 buf += 44; // compiler/backend/parser.c.py:70
 // compiler/backend/parser.c.py:168
 dbg_bytes(pd->headers[header_instance_gbc].pointer, pd->headers[header_instance_gbc].length, // compiler/backend/parser.c.py:173
           "   :: Extracted header instance " T4LIT(#%d) " " T4LIT(gbc,header) "/" T4LIT(%d) "B: ", header_instance_gbc + 1, pd->headers[header_instance_gbc].length); // compiler/backend/parser.c.py:174
  #if PPK_VLAN // compiler/backend/parser.c.py:175
     if (strcmp("parse_gbc", "parse_ethernet") == 0) { // compiler/backend/parser.c.py:176
       uint32_t* tmp = (uint32_t*)buf;    // compiler/backend/parser.c.py:177
       uint32_t vlan1 = *tmp; // compiler/backend/parser.c.py:178
       uint32_t vlan = rte_cpu_to_be_32(vlan1); // compiler/backend/parser.c.py:179
       uint16_t vlanid = (uint16_t)(vlan >> 16) & 0x0fff; // compiler/backend/parser.c.py:180
       uint16_t vlantype = rte_cpu_to_be_16((uint16_t)(vlan)) &0xffff; // compiler/backend/parser.c.py:181
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_instance_type, vlantype); // compiler/backend/parser.c.py:182
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_ethernet, field_ethernet_t_ether_type, vlantype); // compiler/backend/parser.c.py:183
       int ingress_port_value = vlanid - 1000; // compiler/backend/parser.c.py:184
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port, ingress_port_value); // compiler/backend/parser.c.py:185
       debug("       v1model :value of ingress vlan field  " T4LIT(%08x) "\n",GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port)); // compiler/backend/parser.c.py:186
       pd->parsed_length += 4; // compiler/backend/parser.c.py:187
       buf += 4; // compiler/backend/parser.c.py:188
     } // compiler/backend/parser.c.py:189
  #endif // compiler/backend/parser.c.py:190
 
 parser_state_parse_btp(pd, buf, tables, pstate); // compiler/backend/parser.c.py:225
 
 } // compiler/backend/parser.c.py:229
 static void parser_state_parse_btp(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(parse_btp,parserstate) "\n"); // compiler/backend/parser.c.py:112
 // Extracting header parse_btp
  if(unlikely((int)((uint8_t*)buf-(uint8_t*)(pd->data))+4 > pd->wrapper->pkt_len)) // compiler/backend/parser.c.py:57
     ; // packet_too_short // TODO optimize this // compiler/backend/parser.c.py:58
 pd->headers[header_instance_btp].pointer = buf; // compiler/backend/parser.c.py:59
 pd->headers[header_instance_btp].was_enabled_at_initial_parse = true; // compiler/backend/parser.c.py:60
 pd->headers[header_instance_btp].length = 4; // compiler/backend/parser.c.py:61
 pd->parsed_length += 4; // compiler/backend/parser.c.py:62
 buf += 4; // compiler/backend/parser.c.py:70
 // compiler/backend/parser.c.py:168
 dbg_bytes(pd->headers[header_instance_btp].pointer, pd->headers[header_instance_btp].length, // compiler/backend/parser.c.py:173
           "   :: Extracted header instance " T4LIT(#%d) " " T4LIT(btp,header) "/" T4LIT(%d) "B: ", header_instance_btp + 1, pd->headers[header_instance_btp].length); // compiler/backend/parser.c.py:174
  #if PPK_VLAN // compiler/backend/parser.c.py:175
     if (strcmp("parse_btp", "parse_ethernet") == 0) { // compiler/backend/parser.c.py:176
       uint32_t* tmp = (uint32_t*)buf;    // compiler/backend/parser.c.py:177
       uint32_t vlan1 = *tmp; // compiler/backend/parser.c.py:178
       uint32_t vlan = rte_cpu_to_be_32(vlan1); // compiler/backend/parser.c.py:179
       uint16_t vlanid = (uint16_t)(vlan >> 16) & 0x0fff; // compiler/backend/parser.c.py:180
       uint16_t vlantype = rte_cpu_to_be_16((uint16_t)(vlan)) &0xffff; // compiler/backend/parser.c.py:181
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_instance_type, vlantype); // compiler/backend/parser.c.py:182
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_ethernet, field_ethernet_t_ether_type, vlantype); // compiler/backend/parser.c.py:183
       int ingress_port_value = vlanid - 1000; // compiler/backend/parser.c.py:184
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port, ingress_port_value); // compiler/backend/parser.c.py:185
       debug("       v1model :value of ingress vlan field  " T4LIT(%08x) "\n",GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port)); // compiler/backend/parser.c.py:186
       pd->parsed_length += 4; // compiler/backend/parser.c.py:187
       buf += 4; // compiler/backend/parser.c.py:188
     } // compiler/backend/parser.c.py:189
  #endif // compiler/backend/parser.c.py:190
 
 parser_state_parse_its(pd, buf, tables, pstate); // compiler/backend/parser.c.py:225
 
 } // compiler/backend/parser.c.py:229
 static void parser_state_parse_its(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(parse_its,parserstate) "\n"); // compiler/backend/parser.c.py:112
 // Extracting header parse_its
  if(unlikely((int)((uint8_t*)buf-(uint8_t*)(pd->data))+6 > pd->wrapper->pkt_len)) // compiler/backend/parser.c.py:57
     ; // packet_too_short // TODO optimize this // compiler/backend/parser.c.py:58
 pd->headers[header_instance_its].pointer = buf; // compiler/backend/parser.c.py:59
 pd->headers[header_instance_its].was_enabled_at_initial_parse = true; // compiler/backend/parser.c.py:60
 pd->headers[header_instance_its].length = 6; // compiler/backend/parser.c.py:61
 pd->parsed_length += 6; // compiler/backend/parser.c.py:62
 buf += 6; // compiler/backend/parser.c.py:70
 // compiler/backend/parser.c.py:168
 dbg_bytes(pd->headers[header_instance_its].pointer, pd->headers[header_instance_its].length, // compiler/backend/parser.c.py:173
           "   :: Extracted header instance " T4LIT(#%d) " " T4LIT(its,header) "/" T4LIT(%d) "B: ", header_instance_its + 1, pd->headers[header_instance_its].length); // compiler/backend/parser.c.py:174
  #if PPK_VLAN // compiler/backend/parser.c.py:175
     if (strcmp("parse_its", "parse_ethernet") == 0) { // compiler/backend/parser.c.py:176
       uint32_t* tmp = (uint32_t*)buf;    // compiler/backend/parser.c.py:177
       uint32_t vlan1 = *tmp; // compiler/backend/parser.c.py:178
       uint32_t vlan = rte_cpu_to_be_32(vlan1); // compiler/backend/parser.c.py:179
       uint16_t vlanid = (uint16_t)(vlan >> 16) & 0x0fff; // compiler/backend/parser.c.py:180
       uint16_t vlantype = rte_cpu_to_be_16((uint16_t)(vlan)) &0xffff; // compiler/backend/parser.c.py:181
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_instance_type, vlantype); // compiler/backend/parser.c.py:182
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_ethernet, field_ethernet_t_ether_type, vlantype); // compiler/backend/parser.c.py:183
       int ingress_port_value = vlanid - 1000; // compiler/backend/parser.c.py:184
       MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port, ingress_port_value); // compiler/backend/parser.c.py:185
       debug("       v1model :value of ingress vlan field  " T4LIT(%08x) "\n",GET_INT32_AUTO_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_ingress_port)); // compiler/backend/parser.c.py:186
       pd->parsed_length += 4; // compiler/backend/parser.c.py:187
       buf += 4; // compiler/backend/parser.c.py:188
     } // compiler/backend/parser.c.py:189
  #endif // compiler/backend/parser.c.py:190
 
 parser_state_accept(pd, buf, tables, pstate); // compiler/backend/parser.c.py:225
 
 } // compiler/backend/parser.c.py:229
 static void parser_state_parse_tsb(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(parse_tsb,parserstate) "\n"); // compiler/backend/parser.c.py:112
 
 parser_state_accept(pd, buf, tables, pstate); // compiler/backend/parser.c.py:225
 
 } // compiler/backend/parser.c.py:229
 static void parser_state_accept(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(accept,parserstate) "\n"); // compiler/backend/parser.c.py:112
 debug("   :: Packet is " T4LIT(accepted,success) "\n"); // compiler/backend/parser.c.py:207
 pd->payload_length = packet_length(pd) - pd->parsed_length; // compiler/backend/parser.c.py:208
 if (pd->payload_length > 0) { // compiler/backend/parser.c.py:210
     dbg_bytes(pd->data + pd->parsed_length, pd->payload_length, "    : " T4LIT(Payload,header) " is " T4LIT(%d) " bytes: ", pd->payload_length); // compiler/backend/parser.c.py:211
 } else { // compiler/backend/parser.c.py:212
     debug("    : " T4LIT(Payload,header) " is empty\n"); // compiler/backend/parser.c.py:213
 } // compiler/backend/parser.c.py:214
 } // compiler/backend/parser.c.py:229
 static void parser_state_reject(packet_descriptor_t* pd, uint8_t* in_buf, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:107
     uint32_t value32; (void)value32; // compiler/backend/parser.c.py:108
     uint32_t res32; (void)res32; // compiler/backend/parser.c.py:109
     parser_state_t* local_vars = pstate; // compiler/backend/parser.c.py:110
     uint8_t* buf = in_buf; // compiler/backend/parser.c.py:111
     debug(" :::: Parser state " T4LIT(reject,parserstate) "\n"); // compiler/backend/parser.c.py:112
 debug("   :: Packet is " T4LIT(dropped,status) "\n"); // compiler/backend/parser.c.py:216
     MODIFY_INT32_INT32_BITS_PACKET(pd, header_instance_all_metadatas, field_standard_metadata_t_drop, true); // compiler/backend/parser.c.py:217
 } // compiler/backend/parser.c.py:229
 void parse_packet(packet_descriptor_t* pd, lookup_table_t** tables, parser_state_t* pstate) { // compiler/backend/parser.c.py:231
     parser_state_start(pd, pd->data, tables, pstate); // compiler/backend/parser.c.py:232
 } // compiler/backend/parser.c.py:233

 const char* header_instance_names[HEADER_INSTANCE_COUNT] = { // compiler/backend/parser.c.py:236
 "ethernet", // header_instance_ethernet // compiler/backend/parser.c.py:238
 "mf", // header_instance_mf // compiler/backend/parser.c.py:238
 "geo", // header_instance_geo // compiler/backend/parser.c.py:238
 "gbc", // header_instance_gbc // compiler/backend/parser.c.py:238
 "beacon", // header_instance_beacon // compiler/backend/parser.c.py:238
 "btp", // header_instance_btp // compiler/backend/parser.c.py:238
 "its", // header_instance_its // compiler/backend/parser.c.py:238
 "standard_metadata", // header_instance_standard_metadata // compiler/backend/parser.c.py:238
 "meta", // header_instance_meta // compiler/backend/parser.c.py:238
 }; // compiler/backend/parser.c.py:239

 const char* field_names[FIELD_COUNT] = { // compiler/backend/parser.c.py:241
 "dstAddr", // field_instance_ethernet_t_dstAddr // compiler/backend/parser.c.py:244
 "srcAddr", // field_instance_ethernet_t_srcAddr // compiler/backend/parser.c.py:244
 "etherType", // field_instance_ethernet_t_etherType // compiler/backend/parser.c.py:244
 "mf_type", // field_instance_mf_guid_t_mf_type // compiler/backend/parser.c.py:244
 "src_guid", // field_instance_mf_guid_t_src_guid // compiler/backend/parser.c.py:244
 "dest_guid", // field_instance_mf_guid_t_dest_guid // compiler/backend/parser.c.py:244
 "version", // field_instance_ipv4_t_version // compiler/backend/parser.c.py:244
 "ihl", // field_instance_ipv4_t_ihl // compiler/backend/parser.c.py:244
 "dscp", // field_instance_ipv4_t_dscp // compiler/backend/parser.c.py:244
 "ecn", // field_instance_ipv4_t_ecn // compiler/backend/parser.c.py:244
 "total_len", // field_instance_ipv4_t_total_len // compiler/backend/parser.c.py:244
 "identification", // field_instance_ipv4_t_identification // compiler/backend/parser.c.py:244
 "flags", // field_instance_ipv4_t_flags // compiler/backend/parser.c.py:244
 "frag_offset", // field_instance_ipv4_t_frag_offset // compiler/backend/parser.c.py:244
 "ttl", // field_instance_ipv4_t_ttl // compiler/backend/parser.c.py:244
 "protocol", // field_instance_ipv4_t_protocol // compiler/backend/parser.c.py:244
 "hdr_checksum", // field_instance_ipv4_t_hdr_checksum // compiler/backend/parser.c.py:244
 "src_addr", // field_instance_ipv4_t_src_addr // compiler/backend/parser.c.py:244
 "dst_addr", // field_instance_ipv4_t_dst_addr // compiler/backend/parser.c.py:244
 "version", // field_instance_ipv6_t_version // compiler/backend/parser.c.py:244
 "traffic_class", // field_instance_ipv6_t_traffic_class // compiler/backend/parser.c.py:244
 "flow_label", // field_instance_ipv6_t_flow_label // compiler/backend/parser.c.py:244
 "payload_len", // field_instance_ipv6_t_payload_len // compiler/backend/parser.c.py:244
 "next_hdr", // field_instance_ipv6_t_next_hdr // compiler/backend/parser.c.py:244
 "hop_limit", // field_instance_ipv6_t_hop_limit // compiler/backend/parser.c.py:244
 "src_addr", // field_instance_ipv6_t_src_addr // compiler/backend/parser.c.py:244
 "dst_addr", // field_instance_ipv6_t_dst_addr // compiler/backend/parser.c.py:244
 "saved", // field_instance_powerlink_t_saved // compiler/backend/parser.c.py:244
 "message_type", // field_instance_powerlink_t_message_type // compiler/backend/parser.c.py:244
 "dst_node", // field_instance_powerlink_t_dst_node // compiler/backend/parser.c.py:244
 "src_node", // field_instance_powerlink_t_src_node // compiler/backend/parser.c.py:244
 "version", // field_instance_geo_t_version // compiler/backend/parser.c.py:244
 "nh_basic", // field_instance_geo_t_nh_basic // compiler/backend/parser.c.py:244
 "reserved_basic", // field_instance_geo_t_reserved_basic // compiler/backend/parser.c.py:244
 "lt", // field_instance_geo_t_lt // compiler/backend/parser.c.py:244
 "rhl", // field_instance_geo_t_rhl // compiler/backend/parser.c.py:244
 "nh_common", // field_instance_geo_t_nh_common // compiler/backend/parser.c.py:244
 "reserved_common_a", // field_instance_geo_t_reserved_common_a // compiler/backend/parser.c.py:244
 "ht", // field_instance_geo_t_ht // compiler/backend/parser.c.py:244
 "hst", // field_instance_geo_t_hst // compiler/backend/parser.c.py:244
 "tc", // field_instance_geo_t_tc // compiler/backend/parser.c.py:244
 "flag", // field_instance_geo_t_flag // compiler/backend/parser.c.py:244
 "pl", // field_instance_geo_t_pl // compiler/backend/parser.c.py:244
 "mhl", // field_instance_geo_t_mhl // compiler/backend/parser.c.py:244
 "reserved_common_b", // field_instance_geo_t_reserved_common_b // compiler/backend/parser.c.py:244
 "sn", // field_instance_gbc_t_sn // compiler/backend/parser.c.py:244
 "reserved_gbc_a", // field_instance_gbc_t_reserved_gbc_a // compiler/backend/parser.c.py:244
 "gnaddr", // field_instance_gbc_t_gnaddr // compiler/backend/parser.c.py:244
 "tst", // field_instance_gbc_t_tst // compiler/backend/parser.c.py:244
 "lat", // field_instance_gbc_t_lat // compiler/backend/parser.c.py:244
 "longg", // field_instance_gbc_t_longg // compiler/backend/parser.c.py:244
 "pai", // field_instance_gbc_t_pai // compiler/backend/parser.c.py:244
 "s", // field_instance_gbc_t_s // compiler/backend/parser.c.py:244
 "h", // field_instance_gbc_t_h // compiler/backend/parser.c.py:244
 "geoAreaPosLat", // field_instance_gbc_t_geoAreaPosLat // compiler/backend/parser.c.py:244
 "geoAreaPosLon", // field_instance_gbc_t_geoAreaPosLon // compiler/backend/parser.c.py:244
 "disa", // field_instance_gbc_t_disa // compiler/backend/parser.c.py:244
 "disb", // field_instance_gbc_t_disb // compiler/backend/parser.c.py:244
 "angle", // field_instance_gbc_t_angle // compiler/backend/parser.c.py:244
 "reserved_gbc_b", // field_instance_gbc_t_reserved_gbc_b // compiler/backend/parser.c.py:244
 "dstport", // field_instance_btp_t_dstport // compiler/backend/parser.c.py:244
 "dstportinfo", // field_instance_btp_t_dstportinfo // compiler/backend/parser.c.py:244
 "protoversion", // field_instance_its_t_protoversion // compiler/backend/parser.c.py:244
 "messid", // field_instance_its_t_messid // compiler/backend/parser.c.py:244
 "stationid", // field_instance_its_t_stationid // compiler/backend/parser.c.py:244
 "gnaddr", // field_instance_beacon_t_gnaddr // compiler/backend/parser.c.py:244
 "tst", // field_instance_beacon_t_tst // compiler/backend/parser.c.py:244
 "lat", // field_instance_beacon_t_lat // compiler/backend/parser.c.py:244
 "longg", // field_instance_beacon_t_longg // compiler/backend/parser.c.py:244
 "pai", // field_instance_beacon_t_pai // compiler/backend/parser.c.py:244
 "s", // field_instance_beacon_t_s // compiler/backend/parser.c.py:244
 "h", // field_instance_beacon_t_h // compiler/backend/parser.c.py:244
 "ingress_port", // field_instance_standard_metadata_t_ingress_port // compiler/backend/parser.c.py:244
 "egress_spec", // field_instance_standard_metadata_t_egress_spec // compiler/backend/parser.c.py:244
 "egress_port", // field_instance_standard_metadata_t_egress_port // compiler/backend/parser.c.py:244
 "instance_type", // field_instance_standard_metadata_t_instance_type // compiler/backend/parser.c.py:244
 "packet_length", // field_instance_standard_metadata_t_packet_length // compiler/backend/parser.c.py:244
 "enq_timestamp", // field_instance_standard_metadata_t_enq_timestamp // compiler/backend/parser.c.py:244
 "enq_qdepth", // field_instance_standard_metadata_t_enq_qdepth // compiler/backend/parser.c.py:244
 "deq_timedelta", // field_instance_standard_metadata_t_deq_timedelta // compiler/backend/parser.c.py:244
 "deq_qdepth", // field_instance_standard_metadata_t_deq_qdepth // compiler/backend/parser.c.py:244
 "ingress_global_timestamp", // field_instance_standard_metadata_t_ingress_global_timestamp // compiler/backend/parser.c.py:244
 "egress_global_timestamp", // field_instance_standard_metadata_t_egress_global_timestamp // compiler/backend/parser.c.py:244
 "mcast_grp", // field_instance_standard_metadata_t_mcast_grp // compiler/backend/parser.c.py:244
 "egress_rid", // field_instance_standard_metadata_t_egress_rid // compiler/backend/parser.c.py:244
 "checksum_error", // field_instance_standard_metadata_t_checksum_error // compiler/backend/parser.c.py:244
 "parser_error", // field_instance_standard_metadata_t_parser_error // compiler/backend/parser.c.py:244
 "priority", // field_instance_standard_metadata_t_priority // compiler/backend/parser.c.py:244
 "drop", // field_instance_standard_metadata_t_drop // compiler/backend/parser.c.py:244
 }; // compiler/backend/parser.c.py:245

 // Returns the sum of all collected variable widths.
 int get_var_width_bitwidth(parser_state_t* pstate) { // compiler/backend/parser.c.py:249
     int retval = 0 // compiler/backend/parser.c.py:250
     ; // compiler/backend/parser.c.py:253

 return retval; // compiler/backend/parser.c.py:255

 } // compiler/backend/parser.c.py:257
